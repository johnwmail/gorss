// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: visitors.sql

package dbgen

import (
	"context"
	"time"
)

const createCategory = `-- name: CreateCategory :one

INSERT INTO categories (user_id, title) VALUES (?, ?) RETURNING id, user_id, title, created_at
`

type CreateCategoryParams struct {
	UserID string `json:"user_id"`
	Title  string `json:"title"`
}

// Category queries
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, createCategory, arg.UserID, arg.Title)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const createFeed = `-- name: CreateFeed :one

INSERT INTO feeds (user_id, category_id, url, title, site_url, description)
VALUES (?, ?, ?, ?, ?, ?) RETURNING id, user_id, category_id, url, title, site_url, description, last_updated, last_error, created_at
`

type CreateFeedParams struct {
	UserID      string `json:"user_id"`
	CategoryID  *int64 `json:"category_id"`
	Url         string `json:"url"`
	Title       string `json:"title"`
	SiteUrl     string `json:"site_url"`
	Description string `json:"description"`
}

// Feed queries
func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, createFeed,
		arg.UserID,
		arg.CategoryID,
		arg.Url,
		arg.Title,
		arg.SiteUrl,
		arg.Description,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Url,
		&i.Title,
		&i.SiteUrl,
		&i.Description,
		&i.LastUpdated,
		&i.LastError,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = ? AND user_id = ?
`

type DeleteCategoryParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteCategory(ctx context.Context, arg DeleteCategoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, arg.ID, arg.UserID)
	return err
}

const deleteFeed = `-- name: DeleteFeed :exec
DELETE FROM feeds WHERE id = ? AND user_id = ?
`

type DeleteFeedParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteFeed(ctx context.Context, arg DeleteFeedParams) error {
	_, err := q.db.ExecContext(ctx, deleteFeed, arg.ID, arg.UserID)
	return err
}

const getAllFeedsForRefresh = `-- name: GetAllFeedsForRefresh :many
SELECT id, user_id, category_id, url, title, site_url, description, last_updated, last_error, created_at FROM feeds ORDER BY last_updated ASC NULLS FIRST LIMIT ?
`

func (q *Queries) GetAllFeedsForRefresh(ctx context.Context, limit int64) ([]Feed, error) {
	rows, err := q.db.QueryContext(ctx, getAllFeedsForRefresh, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Feed{}
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Url,
			&i.Title,
			&i.SiteUrl,
			&i.Description,
			&i.LastUpdated,
			&i.LastError,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticle = `-- name: GetArticle :one
SELECT a.id, a.feed_id, a.guid, a.url, a.title, a.author, a.content, a.summary, a.published_at, a.created_at, f.title as feed_title, f.site_url as feed_site_url,
  COALESCE(s.is_read, 0) as is_read,
  COALESCE(s.is_starred, 0) as is_starred
FROM articles a
JOIN feeds f ON a.feed_id = f.id
LEFT JOIN article_states s ON s.article_id = a.id AND s.user_id = ?
WHERE a.id = ? AND f.user_id = ?
`

type GetArticleParams struct {
	UserID   string `json:"user_id"`
	ID       int64  `json:"id"`
	UserID_2 string `json:"user_id_2"`
}

type GetArticleRow struct {
	ID          int64      `json:"id"`
	FeedID      int64      `json:"feed_id"`
	Guid        string     `json:"guid"`
	Url         string     `json:"url"`
	Title       string     `json:"title"`
	Author      string     `json:"author"`
	Content     string     `json:"content"`
	Summary     string     `json:"summary"`
	PublishedAt *time.Time `json:"published_at"`
	CreatedAt   time.Time  `json:"created_at"`
	FeedTitle   string     `json:"feed_title"`
	FeedSiteUrl string     `json:"feed_site_url"`
	IsRead      int64      `json:"is_read"`
	IsStarred   int64      `json:"is_starred"`
}

func (q *Queries) GetArticle(ctx context.Context, arg GetArticleParams) (GetArticleRow, error) {
	row := q.db.QueryRowContext(ctx, getArticle, arg.UserID, arg.ID, arg.UserID_2)
	var i GetArticleRow
	err := row.Scan(
		&i.ID,
		&i.FeedID,
		&i.Guid,
		&i.Url,
		&i.Title,
		&i.Author,
		&i.Content,
		&i.Summary,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.FeedTitle,
		&i.FeedSiteUrl,
		&i.IsRead,
		&i.IsStarred,
	)
	return i, err
}

const getArticles = `-- name: GetArticles :many
SELECT a.id, a.feed_id, a.guid, a.url, a.title, a.author, a.content, a.summary, a.published_at, a.created_at, f.title as feed_title, f.site_url as feed_site_url,
  COALESCE(s.is_read, 0) as is_read,
  COALESCE(s.is_starred, 0) as is_starred
FROM articles a
JOIN feeds f ON a.feed_id = f.id
LEFT JOIN article_states s ON s.article_id = a.id AND s.user_id = ?
WHERE f.user_id = ?
ORDER BY a.published_at DESC
LIMIT ? OFFSET ?
`

type GetArticlesParams struct {
	UserID   string `json:"user_id"`
	UserID_2 string `json:"user_id_2"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type GetArticlesRow struct {
	ID          int64      `json:"id"`
	FeedID      int64      `json:"feed_id"`
	Guid        string     `json:"guid"`
	Url         string     `json:"url"`
	Title       string     `json:"title"`
	Author      string     `json:"author"`
	Content     string     `json:"content"`
	Summary     string     `json:"summary"`
	PublishedAt *time.Time `json:"published_at"`
	CreatedAt   time.Time  `json:"created_at"`
	FeedTitle   string     `json:"feed_title"`
	FeedSiteUrl string     `json:"feed_site_url"`
	IsRead      int64      `json:"is_read"`
	IsStarred   int64      `json:"is_starred"`
}

func (q *Queries) GetArticles(ctx context.Context, arg GetArticlesParams) ([]GetArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticles,
		arg.UserID,
		arg.UserID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetArticlesRow{}
	for rows.Next() {
		var i GetArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Guid,
			&i.Url,
			&i.Title,
			&i.Author,
			&i.Content,
			&i.Summary,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.FeedTitle,
			&i.FeedSiteUrl,
			&i.IsRead,
			&i.IsStarred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticlesByFeed = `-- name: GetArticlesByFeed :many
SELECT a.id, a.feed_id, a.guid, a.url, a.title, a.author, a.content, a.summary, a.published_at, a.created_at, f.title as feed_title, f.site_url as feed_site_url,
  COALESCE(s.is_read, 0) as is_read,
  COALESCE(s.is_starred, 0) as is_starred
FROM articles a
JOIN feeds f ON a.feed_id = f.id
LEFT JOIN article_states s ON s.article_id = a.id AND s.user_id = ?
WHERE f.id = ? AND f.user_id = ?
ORDER BY a.published_at DESC
LIMIT ? OFFSET ?
`

type GetArticlesByFeedParams struct {
	UserID   string `json:"user_id"`
	ID       int64  `json:"id"`
	UserID_2 string `json:"user_id_2"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type GetArticlesByFeedRow struct {
	ID          int64      `json:"id"`
	FeedID      int64      `json:"feed_id"`
	Guid        string     `json:"guid"`
	Url         string     `json:"url"`
	Title       string     `json:"title"`
	Author      string     `json:"author"`
	Content     string     `json:"content"`
	Summary     string     `json:"summary"`
	PublishedAt *time.Time `json:"published_at"`
	CreatedAt   time.Time  `json:"created_at"`
	FeedTitle   string     `json:"feed_title"`
	FeedSiteUrl string     `json:"feed_site_url"`
	IsRead      int64      `json:"is_read"`
	IsStarred   int64      `json:"is_starred"`
}

func (q *Queries) GetArticlesByFeed(ctx context.Context, arg GetArticlesByFeedParams) ([]GetArticlesByFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticlesByFeed,
		arg.UserID,
		arg.ID,
		arg.UserID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetArticlesByFeedRow{}
	for rows.Next() {
		var i GetArticlesByFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Guid,
			&i.Url,
			&i.Title,
			&i.Author,
			&i.Content,
			&i.Summary,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.FeedTitle,
			&i.FeedSiteUrl,
			&i.IsRead,
			&i.IsStarred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT id, user_id, title, created_at FROM categories WHERE user_id = ? ORDER BY title
`

func (q *Queries) GetCategories(ctx context.Context, userID string) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategory = `-- name: GetCategory :one
SELECT id, user_id, title, created_at FROM categories WHERE id = ? AND user_id = ?
`

type GetCategoryParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetCategory(ctx context.Context, arg GetCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategory, arg.ID, arg.UserID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const getFeed = `-- name: GetFeed :one
SELECT f.id, f.user_id, f.category_id, f.url, f.title, f.site_url, f.description, f.last_updated, f.last_error, f.created_at, c.title as category_title
FROM feeds f
LEFT JOIN categories c ON f.category_id = c.id
WHERE f.id = ? AND f.user_id = ?
`

type GetFeedParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

type GetFeedRow struct {
	ID            int64      `json:"id"`
	UserID        string     `json:"user_id"`
	CategoryID    *int64     `json:"category_id"`
	Url           string     `json:"url"`
	Title         string     `json:"title"`
	SiteUrl       string     `json:"site_url"`
	Description   string     `json:"description"`
	LastUpdated   *time.Time `json:"last_updated"`
	LastError     *string    `json:"last_error"`
	CreatedAt     time.Time  `json:"created_at"`
	CategoryTitle *string    `json:"category_title"`
}

func (q *Queries) GetFeed(ctx context.Context, arg GetFeedParams) (GetFeedRow, error) {
	row := q.db.QueryRowContext(ctx, getFeed, arg.ID, arg.UserID)
	var i GetFeedRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Url,
		&i.Title,
		&i.SiteUrl,
		&i.Description,
		&i.LastUpdated,
		&i.LastError,
		&i.CreatedAt,
		&i.CategoryTitle,
	)
	return i, err
}

const getFeedByURL = `-- name: GetFeedByURL :one
SELECT id, user_id, category_id, url, title, site_url, description, last_updated, last_error, created_at FROM feeds WHERE user_id = ? AND url = ?
`

type GetFeedByURLParams struct {
	UserID string `json:"user_id"`
	Url    string `json:"url"`
}

func (q *Queries) GetFeedByURL(ctx context.Context, arg GetFeedByURLParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, getFeedByURL, arg.UserID, arg.Url)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Url,
		&i.Title,
		&i.SiteUrl,
		&i.Description,
		&i.LastUpdated,
		&i.LastError,
		&i.CreatedAt,
	)
	return i, err
}

const getFeeds = `-- name: GetFeeds :many
SELECT f.id, f.user_id, f.category_id, f.url, f.title, f.site_url, f.description, f.last_updated, f.last_error, f.created_at, c.title as category_title,
  (SELECT COUNT(*) FROM articles a 
   LEFT JOIN article_states s ON s.article_id = a.id AND s.user_id = f.user_id
   WHERE a.feed_id = f.id AND (s.is_read IS NULL OR s.is_read = 0)) as unread_count
FROM feeds f
LEFT JOIN categories c ON f.category_id = c.id
WHERE f.user_id = ?
ORDER BY f.title
`

type GetFeedsRow struct {
	ID            int64      `json:"id"`
	UserID        string     `json:"user_id"`
	CategoryID    *int64     `json:"category_id"`
	Url           string     `json:"url"`
	Title         string     `json:"title"`
	SiteUrl       string     `json:"site_url"`
	Description   string     `json:"description"`
	LastUpdated   *time.Time `json:"last_updated"`
	LastError     *string    `json:"last_error"`
	CreatedAt     time.Time  `json:"created_at"`
	CategoryTitle *string    `json:"category_title"`
	UnreadCount   int64      `json:"unread_count"`
}

func (q *Queries) GetFeeds(ctx context.Context, userID string) ([]GetFeedsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeeds, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFeedsRow{}
	for rows.Next() {
		var i GetFeedsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Url,
			&i.Title,
			&i.SiteUrl,
			&i.Description,
			&i.LastUpdated,
			&i.LastError,
			&i.CreatedAt,
			&i.CategoryTitle,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStarredArticles = `-- name: GetStarredArticles :many
SELECT a.id, a.feed_id, a.guid, a.url, a.title, a.author, a.content, a.summary, a.published_at, a.created_at, f.title as feed_title, f.site_url as feed_site_url,
  COALESCE(s.is_read, 0) as is_read,
  COALESCE(s.is_starred, 0) as is_starred
FROM articles a
JOIN feeds f ON a.feed_id = f.id
JOIN article_states s ON s.article_id = a.id AND s.user_id = ?
WHERE f.user_id = ? AND s.is_starred = 1
ORDER BY s.starred_at DESC
LIMIT ? OFFSET ?
`

type GetStarredArticlesParams struct {
	UserID   string `json:"user_id"`
	UserID_2 string `json:"user_id_2"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type GetStarredArticlesRow struct {
	ID          int64      `json:"id"`
	FeedID      int64      `json:"feed_id"`
	Guid        string     `json:"guid"`
	Url         string     `json:"url"`
	Title       string     `json:"title"`
	Author      string     `json:"author"`
	Content     string     `json:"content"`
	Summary     string     `json:"summary"`
	PublishedAt *time.Time `json:"published_at"`
	CreatedAt   time.Time  `json:"created_at"`
	FeedTitle   string     `json:"feed_title"`
	FeedSiteUrl string     `json:"feed_site_url"`
	IsRead      int64      `json:"is_read"`
	IsStarred   int64      `json:"is_starred"`
}

func (q *Queries) GetStarredArticles(ctx context.Context, arg GetStarredArticlesParams) ([]GetStarredArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStarredArticles,
		arg.UserID,
		arg.UserID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStarredArticlesRow{}
	for rows.Next() {
		var i GetStarredArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Guid,
			&i.Url,
			&i.Title,
			&i.Author,
			&i.Content,
			&i.Summary,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.FeedTitle,
			&i.FeedSiteUrl,
			&i.IsRead,
			&i.IsStarred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStarredCount = `-- name: GetStarredCount :one
SELECT COUNT(*) as count
FROM article_states s
JOIN articles a ON s.article_id = a.id
JOIN feeds f ON a.feed_id = f.id
WHERE s.user_id = ? AND s.is_starred = 1
`

func (q *Queries) GetStarredCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStarredCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnreadArticles = `-- name: GetUnreadArticles :many
SELECT a.id, a.feed_id, a.guid, a.url, a.title, a.author, a.content, a.summary, a.published_at, a.created_at, f.title as feed_title, f.site_url as feed_site_url,
  COALESCE(s.is_read, 0) as is_read,
  COALESCE(s.is_starred, 0) as is_starred
FROM articles a
JOIN feeds f ON a.feed_id = f.id
LEFT JOIN article_states s ON s.article_id = a.id AND s.user_id = ?
WHERE f.user_id = ? AND (s.is_read IS NULL OR s.is_read = 0)
ORDER BY a.published_at DESC
LIMIT ? OFFSET ?
`

type GetUnreadArticlesParams struct {
	UserID   string `json:"user_id"`
	UserID_2 string `json:"user_id_2"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type GetUnreadArticlesRow struct {
	ID          int64      `json:"id"`
	FeedID      int64      `json:"feed_id"`
	Guid        string     `json:"guid"`
	Url         string     `json:"url"`
	Title       string     `json:"title"`
	Author      string     `json:"author"`
	Content     string     `json:"content"`
	Summary     string     `json:"summary"`
	PublishedAt *time.Time `json:"published_at"`
	CreatedAt   time.Time  `json:"created_at"`
	FeedTitle   string     `json:"feed_title"`
	FeedSiteUrl string     `json:"feed_site_url"`
	IsRead      int64      `json:"is_read"`
	IsStarred   int64      `json:"is_starred"`
}

func (q *Queries) GetUnreadArticles(ctx context.Context, arg GetUnreadArticlesParams) ([]GetUnreadArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadArticles,
		arg.UserID,
		arg.UserID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnreadArticlesRow{}
	for rows.Next() {
		var i GetUnreadArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Guid,
			&i.Url,
			&i.Title,
			&i.Author,
			&i.Content,
			&i.Summary,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.FeedTitle,
			&i.FeedSiteUrl,
			&i.IsRead,
			&i.IsStarred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadCount = `-- name: GetUnreadCount :one

SELECT COUNT(*) as count
FROM articles a
JOIN feeds f ON a.feed_id = f.id
LEFT JOIN article_states s ON s.article_id = a.id AND s.user_id = f.user_id
WHERE f.user_id = ? AND (s.is_read IS NULL OR s.is_read = 0)
`

// Stats queries
func (q *Queries) GetUnreadCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUnreadCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, created_at, last_seen FROM users WHERE id = ?
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.LastSeen,
	)
	return i, err
}

const markAllRead = `-- name: MarkAllRead :exec
INSERT INTO article_states (user_id, article_id, is_read, read_at)
SELECT ?, a.id, 1, ?
FROM articles a
JOIN feeds f ON a.feed_id = f.id
WHERE f.user_id = ?
ON CONFLICT (user_id, article_id) DO UPDATE SET
  is_read = 1,
  read_at = excluded.read_at
`

type MarkAllReadParams struct {
	UserID   string     `json:"user_id"`
	ReadAt   *time.Time `json:"read_at"`
	UserID_2 string     `json:"user_id_2"`
}

func (q *Queries) MarkAllRead(ctx context.Context, arg MarkAllReadParams) error {
	_, err := q.db.ExecContext(ctx, markAllRead, arg.UserID, arg.ReadAt, arg.UserID_2)
	return err
}

const markFeedRead = `-- name: MarkFeedRead :exec
INSERT INTO article_states (user_id, article_id, is_read, read_at)
SELECT ?, a.id, 1, ?
FROM articles a
WHERE a.feed_id = ?
ON CONFLICT (user_id, article_id) DO UPDATE SET
  is_read = 1,
  read_at = excluded.read_at
`

type MarkFeedReadParams struct {
	UserID string     `json:"user_id"`
	ReadAt *time.Time `json:"read_at"`
	FeedID int64      `json:"feed_id"`
}

func (q *Queries) MarkFeedRead(ctx context.Context, arg MarkFeedReadParams) error {
	_, err := q.db.ExecContext(ctx, markFeedRead, arg.UserID, arg.ReadAt, arg.FeedID)
	return err
}

const searchArticles = `-- name: SearchArticles :many
SELECT a.id, a.feed_id, a.guid, a.url, a.title, a.author, a.content, a.summary, a.published_at, a.created_at, f.title as feed_title, f.site_url as feed_site_url,
  COALESCE(s.is_read, 0) as is_read,
  COALESCE(s.is_starred, 0) as is_starred
FROM articles a
JOIN feeds f ON a.feed_id = f.id
LEFT JOIN article_states s ON s.article_id = a.id AND s.user_id = ?
WHERE f.user_id = ? AND (a.title LIKE ? OR a.content LIKE ? OR a.summary LIKE ?)
ORDER BY a.published_at DESC
LIMIT ? OFFSET ?
`

type SearchArticlesParams struct {
	UserID   string `json:"user_id"`
	UserID_2 string `json:"user_id_2"`
	Title    string `json:"title"`
	Content  string `json:"content"`
	Summary  string `json:"summary"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type SearchArticlesRow struct {
	ID          int64      `json:"id"`
	FeedID      int64      `json:"feed_id"`
	Guid        string     `json:"guid"`
	Url         string     `json:"url"`
	Title       string     `json:"title"`
	Author      string     `json:"author"`
	Content     string     `json:"content"`
	Summary     string     `json:"summary"`
	PublishedAt *time.Time `json:"published_at"`
	CreatedAt   time.Time  `json:"created_at"`
	FeedTitle   string     `json:"feed_title"`
	FeedSiteUrl string     `json:"feed_site_url"`
	IsRead      int64      `json:"is_read"`
	IsStarred   int64      `json:"is_starred"`
}

func (q *Queries) SearchArticles(ctx context.Context, arg SearchArticlesParams) ([]SearchArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchArticles,
		arg.UserID,
		arg.UserID_2,
		arg.Title,
		arg.Content,
		arg.Summary,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchArticlesRow{}
	for rows.Next() {
		var i SearchArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Guid,
			&i.Url,
			&i.Title,
			&i.Author,
			&i.Content,
			&i.Summary,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.FeedTitle,
			&i.FeedSiteUrl,
			&i.IsRead,
			&i.IsStarred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setArticleRead = `-- name: SetArticleRead :exec

INSERT INTO article_states (user_id, article_id, is_read, read_at)
VALUES (?, ?, 1, ?)
ON CONFLICT (user_id, article_id) DO UPDATE SET
  is_read = 1,
  read_at = excluded.read_at
`

type SetArticleReadParams struct {
	UserID    string     `json:"user_id"`
	ArticleID int64      `json:"article_id"`
	ReadAt    *time.Time `json:"read_at"`
}

// Article state queries
func (q *Queries) SetArticleRead(ctx context.Context, arg SetArticleReadParams) error {
	_, err := q.db.ExecContext(ctx, setArticleRead, arg.UserID, arg.ArticleID, arg.ReadAt)
	return err
}

const setArticleStarred = `-- name: SetArticleStarred :exec
INSERT INTO article_states (user_id, article_id, is_starred, starred_at)
VALUES (?, ?, 1, ?)
ON CONFLICT (user_id, article_id) DO UPDATE SET
  is_starred = 1,
  starred_at = excluded.starred_at
`

type SetArticleStarredParams struct {
	UserID    string     `json:"user_id"`
	ArticleID int64      `json:"article_id"`
	StarredAt *time.Time `json:"starred_at"`
}

func (q *Queries) SetArticleStarred(ctx context.Context, arg SetArticleStarredParams) error {
	_, err := q.db.ExecContext(ctx, setArticleStarred, arg.UserID, arg.ArticleID, arg.StarredAt)
	return err
}

const setArticleUnread = `-- name: SetArticleUnread :exec
INSERT INTO article_states (user_id, article_id, is_read)
VALUES (?, ?, 0)
ON CONFLICT (user_id, article_id) DO UPDATE SET
  is_read = 0,
  read_at = NULL
`

type SetArticleUnreadParams struct {
	UserID    string `json:"user_id"`
	ArticleID int64  `json:"article_id"`
}

func (q *Queries) SetArticleUnread(ctx context.Context, arg SetArticleUnreadParams) error {
	_, err := q.db.ExecContext(ctx, setArticleUnread, arg.UserID, arg.ArticleID)
	return err
}

const setArticleUnstarred = `-- name: SetArticleUnstarred :exec
INSERT INTO article_states (user_id, article_id, is_starred)
VALUES (?, ?, 0)
ON CONFLICT (user_id, article_id) DO UPDATE SET
  is_starred = 0,
  starred_at = NULL
`

type SetArticleUnstarredParams struct {
	UserID    string `json:"user_id"`
	ArticleID int64  `json:"article_id"`
}

func (q *Queries) SetArticleUnstarred(ctx context.Context, arg SetArticleUnstarredParams) error {
	_, err := q.db.ExecContext(ctx, setArticleUnstarred, arg.UserID, arg.ArticleID)
	return err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories SET title = ? WHERE id = ? AND user_id = ?
`

type UpdateCategoryParams struct {
	Title  string `json:"title"`
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateCategory, arg.Title, arg.ID, arg.UserID)
	return err
}

const updateFeed = `-- name: UpdateFeed :exec
UPDATE feeds SET
  category_id = ?,
  title = ?,
  site_url = ?,
  description = ?,
  last_updated = ?,
  last_error = ?
WHERE id = ?
`

type UpdateFeedParams struct {
	CategoryID  *int64     `json:"category_id"`
	Title       string     `json:"title"`
	SiteUrl     string     `json:"site_url"`
	Description string     `json:"description"`
	LastUpdated *time.Time `json:"last_updated"`
	LastError   *string    `json:"last_error"`
	ID          int64      `json:"id"`
}

func (q *Queries) UpdateFeed(ctx context.Context, arg UpdateFeedParams) error {
	_, err := q.db.ExecContext(ctx, updateFeed,
		arg.CategoryID,
		arg.Title,
		arg.SiteUrl,
		arg.Description,
		arg.LastUpdated,
		arg.LastError,
		arg.ID,
	)
	return err
}

const updateFeedMeta = `-- name: UpdateFeedMeta :exec
UPDATE feeds SET
  title = ?,
  site_url = ?,
  description = ?,
  last_updated = ?,
  last_error = ?
WHERE id = ?
`

type UpdateFeedMetaParams struct {
	Title       string     `json:"title"`
	SiteUrl     string     `json:"site_url"`
	Description string     `json:"description"`
	LastUpdated *time.Time `json:"last_updated"`
	LastError   *string    `json:"last_error"`
	ID          int64      `json:"id"`
}

func (q *Queries) UpdateFeedMeta(ctx context.Context, arg UpdateFeedMetaParams) error {
	_, err := q.db.ExecContext(ctx, updateFeedMeta,
		arg.Title,
		arg.SiteUrl,
		arg.Description,
		arg.LastUpdated,
		arg.LastError,
		arg.ID,
	)
	return err
}

const upsertArticle = `-- name: UpsertArticle :one

INSERT INTO articles (feed_id, guid, url, title, author, content, summary, published_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT (feed_id, guid) DO UPDATE SET
  url = excluded.url,
  title = excluded.title,
  author = excluded.author,
  content = excluded.content,
  summary = excluded.summary,
  published_at = excluded.published_at
RETURNING id, feed_id, guid, url, title, author, content, summary, published_at, created_at
`

type UpsertArticleParams struct {
	FeedID      int64      `json:"feed_id"`
	Guid        string     `json:"guid"`
	Url         string     `json:"url"`
	Title       string     `json:"title"`
	Author      string     `json:"author"`
	Content     string     `json:"content"`
	Summary     string     `json:"summary"`
	PublishedAt *time.Time `json:"published_at"`
}

// Article queries
func (q *Queries) UpsertArticle(ctx context.Context, arg UpsertArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, upsertArticle,
		arg.FeedID,
		arg.Guid,
		arg.Url,
		arg.Title,
		arg.Author,
		arg.Content,
		arg.Summary,
		arg.PublishedAt,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.FeedID,
		&i.Guid,
		&i.Url,
		&i.Title,
		&i.Author,
		&i.Content,
		&i.Summary,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :exec

INSERT INTO users (id, email, created_at, last_seen)
VALUES (?, ?, ?, ?)
ON CONFLICT (id) DO UPDATE SET
  email = excluded.email,
  last_seen = excluded.last_seen
`

type UpsertUserParams struct {
	ID        string    `json:"id"`
	Email     *string   `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	LastSeen  time.Time `json:"last_seen"`
}

// User queries
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.ExecContext(ctx, upsertUser,
		arg.ID,
		arg.Email,
		arg.CreatedAt,
		arg.LastSeen,
	)
	return err
}
